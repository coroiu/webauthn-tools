{"version":3,"file":"325.5338b32236ee7159.js","mappings":"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","names":["POW_2_32","POW_2_53","TaggedValue","constructor","value","tag","this","CBOR","decode","data","tagger","simpleValue","ignoreTrailingData","dataView","DataView","ta","Uint8Array","offset","tagValueFunction","simpleValFunction","commitRead","length","readArrayBuffer","readUint8","readUint16","getUint16","readUint32","getUint32","readBreak","readLength","additionalInformation","readUint64","Error","readIndefiniteStringLength","majorType","initialByte","appendUtf16Data","utf16data","i","push","ret","decodeItem","readFloat16","tempArrayBuffer","ArrayBuffer","tempDataView","sign","exponent","fraction","setUint32","getFloat32","readFloat32","readFloat64","getFloat64","elements","fullArrayLength","fullArray","fullArrayOffset","set","string","String","fromCharCode","apply","slice","retArray","Array","retObject","byteLength","encode","lastLength","byteView","prepareWrite","newByteLength","requiredLength","oldDataView","uint32count","commitWrite","args","writeUint8","val","setUint8","writeUint8Array","writeUint16","setUint16","writeUint32","writeUint64","low","high","view","writeTypeAndLength","type","encodeItem","undefined","objectIs","x","y","Object","is","Math","floor","writeFloat64","setFloat64","utf8data","charCode","charCodeAt","converted","isArray","isView","buffer","SharedArrayBuffer","writeVarUint","mod","keys","key","retView","getUint8","tryDecode","error","console","decodeBase64Url","input","atob","replace","split","map","c","BufferReader","remaining","read","bytes","readByte","readUInt32BE","readUInt16BE","getCopyOfRemainingData","toHexString","byteArray","from","byte","toString","padStart","join","recursiveConvertArrayBufferToHexString","fromEntries","entries","decodePublicKeyAlgorithm","decodeAuthenticatorData","reader","flags","rpIdHash","flagsByte","userPresence","reserved1","userVerification","backupEligibility","backupState","reserved2","attestationData","extensionData","result","counter","attestedCredentialData","decodeAttestedCredentialData","remainingData","unsupportedData","attestationMinLen","aaguid","toUuidStandardFormat","hex","credentialIdLength","credentialId","credentialPublicKey","decodeWebAuthnOptionsPubKeyCredParam","alg","decodeCreate","options","publicKey","pubKeyCredParams","excludeCredentials","response","authenticatorAttachment","getClientExtensionResults","id","rawId","attestationObject","decodeAttestationObject","clientDataJSON","JSON","parse","getAuthenticatorData","getPublicKey","getPublicKeyAlgorithm","getTransports","cborMap","log","attStmt","authData"],"sourceRoot":"webpack:///","sources":["./src/app/pages/analysis/analyze/cbor.ts","./src/app/pages/analysis/analyze/decode-common.ts","./src/app/pages/analysis/analyze/decode-create.ts"],"sourcesContent":["/**\nThe MIT License (MIT)\n\nCopyright (c) 2014-2016 Patrick Gansterer <paroga@paroga.com>\nCopyright (c) 2020-present Aaron Huggins <ahuggins@aaronhuggins.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nExported from GitHub release version 0.4.0\n\nModified by Andreas Coroiu\n*/\n\n/* eslint-disable */\n/** @hidden */\nconst POW_2_24 = 5.960464477539063e-8;\n/** @hidden */\nconst POW_2_32 = 4294967296;\n/** @hidden */\nconst POW_2_53 = 9007199254740992;\n/** @hidden */\nconst DECODE_CHUNK_SIZE = 8192;\n\n/** @hidden */\nfunction objectIs(x: any, y: any) {\n  if (typeof Object.is === 'function') return Object.is(x, y);\n\n  // SameValue algorithm\n  // Steps 1-5, 7-10\n  if (x === y) {\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // Step 6.a: NaN == NaN\n  return x !== x && y !== y;\n}\n\n/** A function that extracts tagged values. */\ntype TaggedValueFunction = (value: any, tag: number) => TaggedValue;\n/** A function that extracts simple values. */\ntype SimpleValueFunction = (value: any) => SimpleValue;\n\n/** Convenience class for structuring a tagged value. */\nexport class TaggedValue {\n  constructor(value: any, tag: number) {\n    this.value = value;\n    this.tag = tag;\n  }\n\n  value: any;\n  tag: number;\n}\n\n/** Convenience class for structuring a simple value. */\nexport class SimpleValue {\n  constructor(value: any) {\n    this.value = value;\n  }\n\n  value: any;\n}\n\n/**\n * Converts a Concise Binary Object Representation (CBOR) buffer into an object.\n * @param {ArrayBuffer|SharedArrayBuffer} data - A valid CBOR buffer.\n * @param {Function} [tagger] - A function that extracts tagged values. This function is called for each member of the object.\n * @param {Function} [simpleValue] - A function that extracts simple values. This function is called for each member of the object.\n * @returns {any} The CBOR buffer converted to a JavaScript value.\n */\nexport function decode<T = any>(\n  data: ArrayBuffer | SharedArrayBuffer,\n  {\n    tagger,\n    simpleValue,\n    ignoreTrailingData,\n  }: {\n    tagger?: TaggedValueFunction;\n    simpleValue?: SimpleValueFunction;\n    ignoreTrailingData?: boolean;\n  } = {}\n): [T, number] {\n  let dataView = new DataView(data);\n  let ta = new Uint8Array(data);\n  let offset = 0;\n  let tagValueFunction: TaggedValueFunction = function (\n    value: number,\n    tag: number\n  ): any {\n    return new TaggedValue(value, tag);\n  };\n  let simpleValFunction: SimpleValueFunction = function (\n    value: number\n  ): SimpleValue {\n    return undefined as unknown as SimpleValue;\n  };\n\n  if (typeof tagger === 'function') tagValueFunction = tagger;\n  if (typeof simpleValue === 'function') simpleValFunction = simpleValue;\n\n  function commitRead<T>(length: number, value: T): T {\n    offset += length;\n    return value;\n  }\n  function readArrayBuffer(length: number) {\n    return commitRead(length, new Uint8Array(data, offset, length));\n  }\n  function readFloat16() {\n    let tempArrayBuffer = new ArrayBuffer(4);\n    let tempDataView = new DataView(tempArrayBuffer);\n    let value = readUint16();\n\n    let sign = value & 0x8000;\n    let exponent = value & 0x7c00;\n    let fraction = value & 0x03ff;\n\n    if (exponent === 0x7c00) exponent = 0xff << 10;\n    else if (exponent !== 0) exponent += (127 - 15) << 10;\n    else if (fraction !== 0) return (sign ? -1 : 1) * fraction * POW_2_24;\n\n    tempDataView.setUint32(\n      0,\n      (sign << 16) | (exponent << 13) | (fraction << 13)\n    );\n    return tempDataView.getFloat32(0);\n  }\n  function readFloat32(): number {\n    return commitRead(4, dataView.getFloat32(offset));\n  }\n  function readFloat64(): number {\n    return commitRead(8, dataView.getFloat64(offset));\n  }\n  function readUint8(): number {\n    return commitRead(1, ta[offset]);\n  }\n  function readUint16(): number {\n    return commitRead(2, dataView.getUint16(offset));\n  }\n  function readUint32(): number {\n    return commitRead(4, dataView.getUint32(offset));\n  }\n  function readUint64(): number {\n    return readUint32() * POW_2_32 + readUint32();\n  }\n  function readBreak(): boolean {\n    if (ta[offset] !== 0xff) return false;\n    offset += 1;\n    return true;\n  }\n  function readLength(additionalInformation: number): number {\n    if (additionalInformation < 24) return additionalInformation;\n    if (additionalInformation === 24) return readUint8();\n    if (additionalInformation === 25) return readUint16();\n    if (additionalInformation === 26) return readUint32();\n    if (additionalInformation === 27) return readUint64();\n    if (additionalInformation === 31) return -1;\n    throw new Error('Invalid length encoding');\n  }\n  function readIndefiniteStringLength(majorType: number): number {\n    let initialByte = readUint8();\n    if (initialByte === 0xff) return -1;\n    let length = readLength(initialByte & 0x1f);\n    if (length < 0 || initialByte >> 5 !== majorType)\n      throw new Error('Invalid indefinite length element');\n    return length;\n  }\n\n  function appendUtf16Data(utf16data: number[], length: number) {\n    for (let i = 0; i < length; ++i) {\n      let value = readUint8();\n      if (value & 0x80) {\n        if (value < 0xe0) {\n          value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);\n          length -= 1;\n        } else if (value < 0xf0) {\n          value =\n            ((value & 0x0f) << 12) |\n            ((readUint8() & 0x3f) << 6) |\n            (readUint8() & 0x3f);\n          length -= 2;\n        } else {\n          value =\n            ((value & 0x0f) << 18) |\n            ((readUint8() & 0x3f) << 12) |\n            ((readUint8() & 0x3f) << 6) |\n            (readUint8() & 0x3f);\n          length -= 3;\n        }\n      }\n\n      if (value < 0x10000) {\n        utf16data.push(value);\n      } else {\n        value -= 0x10000;\n        utf16data.push(0xd800 | (value >> 10));\n        utf16data.push(0xdc00 | (value & 0x3ff));\n      }\n    }\n  }\n\n  function decodeItem(): any {\n    let initialByte = readUint8();\n    let majorType = initialByte >> 5;\n    let additionalInformation = initialByte & 0x1f;\n    let i;\n    let length;\n\n    if (majorType === 7) {\n      switch (additionalInformation) {\n        case 25:\n          return readFloat16();\n        case 26:\n          return readFloat32();\n        case 27:\n          return readFloat64();\n      }\n    }\n\n    length = readLength(additionalInformation);\n    if (length < 0 && (majorType < 2 || 6 < majorType))\n      throw new Error('Invalid length');\n\n    switch (majorType) {\n      case 0:\n        return length;\n      case 1:\n        return -1 - length;\n      case 2:\n        if (length < 0) {\n          let elements = [];\n          let fullArrayLength = 0;\n          while ((length = readIndefiniteStringLength(majorType)) >= 0) {\n            fullArrayLength += length;\n            elements.push(readArrayBuffer(length));\n          }\n          let fullArray = new Uint8Array(fullArrayLength);\n          let fullArrayOffset = 0;\n          for (i = 0; i < elements.length; ++i) {\n            fullArray.set(elements[i], fullArrayOffset);\n            fullArrayOffset += elements[i].length;\n          }\n          return fullArray;\n        }\n        return readArrayBuffer(length);\n      case 3:\n        let utf16data: number[] = [];\n        if (length < 0) {\n          while ((length = readIndefiniteStringLength(majorType)) >= 0)\n            appendUtf16Data(utf16data, length);\n        } else {\n          appendUtf16Data(utf16data, length);\n        }\n        let string = '';\n        for (i = 0; i < utf16data.length; i += DECODE_CHUNK_SIZE) {\n          string += String.fromCharCode.apply(\n            null,\n            utf16data.slice(i, i + DECODE_CHUNK_SIZE)\n          );\n        }\n        return string;\n      case 4:\n        let retArray;\n        if (length < 0) {\n          retArray = [];\n          while (!readBreak()) retArray.push(decodeItem());\n        } else {\n          retArray = new Array(length);\n          for (i = 0; i < length; ++i) retArray[i] = decodeItem();\n        }\n        return retArray;\n      case 5:\n        let retObject: any = {};\n        for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {\n          let key = decodeItem();\n          retObject[key] = decodeItem();\n        }\n        return retObject;\n      case 6:\n        return tagValueFunction(decodeItem(), length);\n      case 7:\n        switch (length) {\n          case 20:\n            return false;\n          case 21:\n            return true;\n          case 22:\n            return null;\n          case 23:\n            return undefined;\n          default:\n            return simpleValFunction(length);\n        }\n    }\n  }\n\n  let ret = decodeItem();\n  if (offset !== data.byteLength && !ignoreTrailingData)\n    throw new Error('Remaining bytes');\n  return [ret, offset];\n}\n\n/**\n * Converts a JavaScript value to a Concise Binary Object Representation (CBOR) buffer.\n * @param {any} value - A JavaScript value, usually an object or array, to be converted.\n * @returns {ArrayBuffer} The JavaScript value converted to CBOR format.\n */\nexport function encode<T = any>(value: T): ArrayBuffer {\n  let data = new ArrayBuffer(256);\n  let dataView = new DataView(data);\n  let byteView = new Uint8Array(data);\n  let lastLength: number;\n  let offset = 0;\n\n  function prepareWrite(length: number): DataView {\n    let newByteLength = data.byteLength;\n    let requiredLength = offset + length;\n    while (newByteLength < requiredLength) newByteLength <<= 1;\n    if (newByteLength !== data.byteLength) {\n      let oldDataView = dataView;\n      data = new ArrayBuffer(newByteLength);\n      dataView = new DataView(data);\n      byteView = new Uint8Array(data);\n      let uint32count = (offset + 3) >> 2;\n      for (let i = 0; i < uint32count; ++i)\n        dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));\n    }\n\n    lastLength = length;\n    return dataView;\n  }\n  function commitWrite(...args: any[]) {\n    offset += lastLength;\n  }\n  function writeFloat64(val: number) {\n    commitWrite(prepareWrite(8).setFloat64(offset, val));\n  }\n  function writeUint8(val: number) {\n    commitWrite(prepareWrite(1).setUint8(offset, val));\n  }\n  function writeUint8Array(val: number[] | Uint8Array) {\n    prepareWrite(val.length);\n    byteView.set(val, offset);\n    commitWrite();\n  }\n  function writeUint16(val: number) {\n    commitWrite(prepareWrite(2).setUint16(offset, val));\n  }\n  function writeUint32(val: number) {\n    commitWrite(prepareWrite(4).setUint32(offset, val));\n  }\n  function writeUint64(val: number) {\n    let low = val % POW_2_32;\n    let high = (val - low) / POW_2_32;\n    let view = prepareWrite(8);\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n    commitWrite();\n  }\n  function writeVarUint(val: number, mod: number = 0) {\n    if (val <= 0xff) {\n      if (val < 24) {\n        writeUint8(val | mod);\n      } else {\n        writeUint8(0x18 | mod);\n        writeUint8(val);\n      }\n    } else if (val <= 0xffff) {\n      writeUint8(0x19 | mod);\n      writeUint16(val);\n    } else if (val <= 0xffffffff) {\n      writeUint8(0x1a | mod);\n      writeUint32(val);\n    } else {\n      writeUint8(0x1b | mod);\n      writeUint64(val);\n    }\n  }\n  function writeTypeAndLength(type: number, length: number) {\n    if (length < 24) {\n      writeUint8((type << 5) | length);\n    } else if (length < 0x100) {\n      writeUint8((type << 5) | 24);\n      writeUint8(length);\n    } else if (length < 0x10000) {\n      writeUint8((type << 5) | 25);\n      writeUint16(length);\n    } else if (length < 0x100000000) {\n      writeUint8((type << 5) | 26);\n      writeUint32(length);\n    } else {\n      writeUint8((type << 5) | 27);\n      writeUint64(length);\n    }\n  }\n\n  function encodeItem(val: any) {\n    let i;\n\n    if (val === false) return writeUint8(0xf4);\n    if (val === true) return writeUint8(0xf5);\n    if (val === null) return writeUint8(0xf6);\n    if (val === undefined) return writeUint8(0xf7);\n    if (objectIs(val, -0)) return writeUint8Array([0xf9, 0x80, 0x00]);\n\n    switch (typeof val) {\n      case 'number':\n        if (Math.floor(val) === val) {\n          if (0 <= val && val <= POW_2_53) return writeTypeAndLength(0, val);\n          if (-POW_2_53 <= val && val < 0)\n            return writeTypeAndLength(1, -(val + 1));\n        }\n        writeUint8(0xfb);\n        return writeFloat64(val);\n\n      case 'string':\n        let utf8data = [];\n        for (i = 0; i < val.length; ++i) {\n          let charCode = val.charCodeAt(i);\n          if (charCode < 0x80) {\n            utf8data.push(charCode);\n          } else if (charCode < 0x800) {\n            utf8data.push(0xc0 | (charCode >> 6));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else if (charCode < 0xd800 || charCode >= 0xe000) {\n            utf8data.push(0xe0 | (charCode >> 12));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          } else {\n            charCode = (charCode & 0x3ff) << 10;\n            charCode |= val.charCodeAt(++i) & 0x3ff;\n            charCode += 0x10000;\n\n            utf8data.push(0xf0 | (charCode >> 18));\n            utf8data.push(0x80 | ((charCode >> 12) & 0x3f));\n            utf8data.push(0x80 | ((charCode >> 6) & 0x3f));\n            utf8data.push(0x80 | (charCode & 0x3f));\n          }\n        }\n\n        writeTypeAndLength(3, utf8data.length);\n        return writeUint8Array(utf8data);\n\n      default:\n        let length;\n        let converted;\n        if (Array.isArray(val)) {\n          length = val.length;\n          writeTypeAndLength(4, length);\n          for (i = 0; i < length; i += 1) encodeItem(val[i]);\n        } else if (val instanceof Uint8Array) {\n          writeTypeAndLength(2, val.length);\n          writeUint8Array(val);\n        } else if (ArrayBuffer.isView(val)) {\n          converted = new Uint8Array(val.buffer);\n          writeTypeAndLength(2, converted.length);\n          writeUint8Array(converted);\n        } else if (\n          val instanceof ArrayBuffer ||\n          (typeof SharedArrayBuffer === 'function' &&\n            val instanceof SharedArrayBuffer)\n        ) {\n          converted = new Uint8Array(val);\n          writeTypeAndLength(2, converted.length);\n          writeUint8Array(converted);\n        } else if (val instanceof TaggedValue) {\n          writeVarUint(val.tag, 0b11000000);\n          encodeItem(val.value);\n        } else {\n          let keys = Object.keys(val);\n          length = keys.length;\n          writeTypeAndLength(5, length);\n          for (i = 0; i < length; i += 1) {\n            let key = keys[i];\n            encodeItem(key);\n            encodeItem(val[key]);\n          }\n        }\n    }\n  }\n\n  encodeItem(value);\n\n  if ('slice' in data) return data.slice(0, offset);\n\n  let ret = new ArrayBuffer(offset);\n  let retView = new DataView(ret);\n  for (let i = 0; i < offset; ++i) retView.setUint8(i, dataView.getUint8(i));\n  return ret;\n}\n\n/**\n * An intrinsic object that provides functions to convert JavaScript values\n * to and from the Concise Binary Object Representation (CBOR) format.\n */\nexport const CBOR = {\n  decode,\n  encode,\n};\n","import {\n  DecodedAttestedCredentialData,\n  DecodedAuthenticatorData,\n  DecodedWebAuthnOptionsPubKeyCredParam,\n  WebAuthnOptionsPubKeyCredParam,\n} from '../../../types/webauthn-challenge-response';\nimport { CBOR } from './cbor';\n\n/** Hacky method to return a an error message even if the data is not of the correct type */\nexport function tryDecode<T>(decode: () => T): T {\n  try {\n    return decode();\n  } catch (error) {\n    console.error(error);\n    return `[Unable to decode; Error: ${error}]` as any;\n  }\n}\n\nexport function decodeBase64Url(input: string): Uint8Array {\n  return new Uint8Array(\n    atob(input.replace(/-/g, '+').replace(/_/g, '/'))\n      .split('')\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport class BufferReader {\n  private offset = 0;\n\n  constructor(private buffer: Uint8Array) {}\n\n  get remaining() {\n    return this.buffer.length - this.offset;\n  }\n\n  read(bytes: number): Uint8Array {\n    if (bytes > this.remaining) {\n      throw new Error(\n        `Trying to read ${bytes} bytes, but only ${this.remaining} bytes are available`\n      );\n    }\n    const value = this.buffer.slice(this.offset, this.offset + bytes);\n    this.offset += bytes;\n    return value;\n  }\n\n  readByte(): number {\n    return this.read(1)[0];\n  }\n\n  readUInt32BE(): number {\n    const value = this.read(4);\n    return (value[0] << 24) | (value[1] << 16) | (value[2] << 8) | value[3];\n  }\n\n  readUInt16BE(): number {\n    const value = this.read(2);\n    return (value[0] << 8) | value[1];\n  }\n\n  getCopyOfRemainingData(): Uint8Array {\n    return this.buffer.slice(this.offset);\n  }\n}\n\nexport function toHexString(byteArray: Uint8Array) {\n  return Array.from(byteArray, (byte) =>\n    byte.toString(16).padStart(2, '0')\n  ).join('');\n}\n\nexport function toUuidStandardFormat(buffer: Uint8Array) {\n  const hex = toHexString(buffer);\n  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(\n    12,\n    16\n  )}-${hex.slice(16, 20)}-${hex.slice(20)}`;\n}\n\nexport function recursiveConvertArrayBufferToHexString(data: object): any {\n  if (data instanceof ArrayBuffer) {\n    return toHexString(new Uint8Array(data));\n  }\n  if (data instanceof Uint8Array) {\n    return toHexString(data);\n  }\n  if (Array.isArray(data)) {\n    return data.map(recursiveConvertArrayBufferToHexString);\n  }\n  if (typeof data === 'object') {\n    return Object.fromEntries(\n      Object.entries(data).map(([key, value]) => [\n        key,\n        recursiveConvertArrayBufferToHexString(value),\n      ])\n    );\n  }\n  return data;\n}\n\nexport function decodePublicKeyAlgorithm(data: number): string;\nexport function decodePublicKeyAlgorithm(data: undefined): undefined;\nexport function decodePublicKeyAlgorithm(\n  data: number | undefined\n): string | undefined {\n  if (data === undefined) {\n    return undefined;\n  }\n\n  const map: Record<string, string | undefined> = {\n    '-65535': 'RS1',\n    '-65534': 'A128CTR',\n    '-65533': 'A192CTR',\n    '-65532': 'A256CTR',\n    '-65531': 'A128CBC',\n    '-65530': 'A192CBC',\n    '-65529': 'A256CBC',\n    '-260': 'WalnutDSA',\n    '-259': 'RS512',\n    '-258': 'RS384',\n    '-257': 'RS256',\n    '-47': 'ES256K',\n    '-46': 'HSS-LMS',\n    '-45': 'SHAKE256',\n    '-44': 'SHA-512',\n    '-43': 'SHA-384',\n    '-42': 'RSAES-OAEP w/ SHA-512',\n    '-41': 'RSAES-OAEP w/ SHA-256',\n    '-40': 'RSAES-OAEP w/ RFC 8017 default parameters',\n    '-39': 'PS512',\n    '-38': 'PS384',\n    '-37': 'PS256',\n    '-36': 'ES512',\n    '-35': 'ES384',\n    '-34': 'ECDH-SS + A256KW',\n    '-33': 'ECDH-SS + A192KW',\n    '-32': 'ECDH-SS + A128KW',\n    '-31': 'ECDH-ES + A256KW',\n    '-30': 'ECDH-ES + A192KW',\n    '-29': 'ECDH-ES + A128KW',\n    '-28': 'ECDH-SS + HKDF-512',\n    '-27': 'ECDH-SS + HKDF-256',\n    '-26': 'ECDH-ES + HKDF-512',\n    '-25': 'ECDH-ES + HKDF-256',\n    '-18': 'SHAKE128',\n    '-17': 'SHA-512/256',\n    '-16': 'SHA-256',\n    '-15': 'SHA-256/64',\n    '-14': 'SHA-1',\n    '-13': 'direct+HKDF-AES-256',\n    '-12': 'direct+HKDF-AES-128',\n    '-11': 'direct+HKDF-SHA-512',\n    '-10': 'direct+HKDF-SHA-256',\n    '-8': 'EdDSA',\n    '-7': 'ES256',\n    '-6': 'direct',\n    '-5': 'A256KW',\n    '-4': 'A192KW',\n    '-3': 'A128KW',\n    '1': 'A128GCM',\n    '2': 'A192GCM',\n    '3': 'A256GCM',\n    '4': 'HMAC 256/64',\n    '5': 'HMAC 256/256',\n    '6': 'HMAC 384/384',\n    '7': 'HMAC 512/512',\n    '10': 'AES-CCM-16-64-128',\n    '11': 'AES-CCM-16-64-256',\n    '12': 'AES-CCM-64-64-128',\n    '13': 'AES-CCM-64-64-256',\n    '14': 'AES-MAC 128/64',\n    '15': 'AES-MAC 256/64',\n    '24': 'ChaCha20/Poly1305',\n    '25': 'AES-MAC 128/128',\n    '26': 'AES-MAC 256/128',\n    '30': 'AES-CCM-16-128-128',\n    '31': 'AES-CCM-16-128-256',\n    '32': 'AES-CCM-64-128-128',\n    '33': 'AES-CCM-64-128-256',\n    '34': 'IV-GENERATION',\n  };\n\n  const key = String(data);\n  const value = map[key];\n\n  if (value == undefined) {\n    return `[Unknown algorithm: ${key}]`;\n  }\n\n  return value;\n}\n\nexport function decodeAuthenticatorData(\n  data: string | Uint8Array\n): DecodedAuthenticatorData {\n  const buffer = data instanceof Uint8Array ? data : decodeBase64Url(data);\n  if (buffer.length < 37) {\n    throw new Error('Authenticator data is too short');\n  }\n  const reader = new BufferReader(buffer);\n  let rpIdHash = toHexString(reader.read(32));\n  let flagsByte = reader.readByte();\n\n  let flags;\n  // prettier-ignore\n  {\n    let userPresence      = !!(flagsByte & 0b00000001);\n    let reserved1         = !!(flagsByte & 0b00000010);\n    let userVerification  = !!(flagsByte & 0b00000100);\n    let backupEligibility = !!(flagsByte & 0b00001000);\n    let backupState       = !!(flagsByte & 0b00010000);\n    let reserved2         = !!(flagsByte & 0b00100000);\n    let attestationData      = !!(flagsByte & 0b01000000);\n    let extensionData     = !!(flagsByte & 0b10000000);\n    flags = {\n      userPresence,\n      reserved1,\n      userVerification,\n      backupEligibility,\n      backupState,\n      reserved2,\n      attestationData,\n      extensionData\n    };\n  }\n\n  const counter = reader.readUInt32BE();\n\n  const result = {\n    rpIdHash,\n    flags,\n    counter,\n    attestedCredentialData: flags.attestationData\n      ? tryDecode(() => decodeAttestedCredentialData(reader))\n      : undefined,\n  } as DecodedAuthenticatorData;\n\n  if (flags.extensionData) {\n    result.extensionData = tryDecode(() => {\n      const remainingData = reader.getCopyOfRemainingData();\n      const [data, length] = CBOR.decode(remainingData.buffer, {\n        ignoreTrailingData: true,\n      });\n      reader.read(length);\n      return recursiveConvertArrayBufferToHexString(data);\n    });\n  }\n\n  if (reader.remaining > 0) {\n    result.unsupportedData = toHexString(reader.read(reader.remaining));\n  }\n\n  return result;\n}\n\nexport function decodeAttestedCredentialData(\n  reader: BufferReader\n): DecodedAttestedCredentialData {\n  const attestationMinLen = 16 + 2 + 16 + 42; // aaguid + credIdLen + credId + pk\n  if (reader.remaining < attestationMinLen)\n    throw new Error(\n      `The attestationData flag is set, but the remaining data is smaller than ${attestationMinLen} bytes. Did we encounter the attestationData flag for an assertion response?`\n    );\n  const aaguid = toUuidStandardFormat(reader.read(16));\n  const credentialIdLength = reader.readUInt16BE();\n  const credentialId = toHexString(reader.read(credentialIdLength));\n  const credentialPublicKey = tryDecode(() => {\n    const remainingData = reader.getCopyOfRemainingData();\n    // Ignore data for the moment\n    const [data, length] = CBOR.decode(remainingData.buffer, {\n      ignoreTrailingData: true,\n    });\n    reader.read(length);\n    return recursiveConvertArrayBufferToHexString(data);\n    // const rawCredentialPublicKey = reader.read(length);\n    // return toHexString(rawCredentialPublicKey);\n  });\n  return {\n    aaguid,\n    credentialIdLength,\n    credentialId,\n    credentialPublicKey,\n  };\n}\n\nexport function decodeWebAuthnOptionsPubKeyCredParam(\n  data: WebAuthnOptionsPubKeyCredParam\n): DecodedWebAuthnOptionsPubKeyCredParam {\n  return {\n    ...data,\n    alg: decodePublicKeyAlgorithm(data.alg),\n  };\n}\n","import {\n  DecodedAttestationObject,\n  DecodedAttestedCredentialData,\n  DecodedAuthenticatorData,\n  DecodedWebAuthnCreateChallengeResponse,\n  WebAuthnCreateChallengeResponse,\n} from '../../../types/webauthn-challenge-response';\n\nimport { CBOR } from './cbor';\nimport {\n  BufferReader,\n  decodeAuthenticatorData,\n  decodeBase64Url,\n  decodePublicKeyAlgorithm,\n  decodeWebAuthnOptionsPubKeyCredParam,\n  recursiveConvertArrayBufferToHexString,\n  toHexString,\n  toUuidStandardFormat,\n  tryDecode,\n} from './decode-common';\n\nexport function decodeCreate(\n  input: WebAuthnCreateChallengeResponse\n): DecodedWebAuthnCreateChallengeResponse {\n  return {\n    ...input,\n    options: {\n      ...input.options,\n      publicKey: {\n        ...input.options.publicKey,\n        pubKeyCredParams: tryDecode(() =>\n          input.options.publicKey.pubKeyCredParams?.map(\n            decodeWebAuthnOptionsPubKeyCredParam\n          )\n        ),\n        excludeCredentials: tryDecode(() =>\n          input.options.publicKey.excludeCredentials?.map(\n            decodeWebAuthnOptionsPubKeyCredParam\n          )\n        ),\n      },\n    },\n    response: {\n      value: {\n        authenticatorAttachment: input.response.value.authenticatorAttachment,\n        getClientExtensionResults:\n          input.response.value.getClientExtensionResults,\n        id: input.response.value.id,\n        rawId: toHexString(decodeBase64Url(input.response.value.rawId)),\n        type: input.response.value.type,\n        response: {\n          attestationObject: tryDecode(() =>\n            decodeAttestationObject(\n              input.response.value.response.attestationObject\n            )\n          ),\n          clientDataJSON: tryDecode(() =>\n            JSON.parse(atob(input.response.value.response.clientDataJSON))\n          ),\n          getAuthenticatorData: tryDecode(() =>\n            decodeAuthenticatorData(\n              input.response.value.response.getAuthenticatorData\n            )\n          ),\n          getPublicKey: tryDecode(() =>\n            toHexString(\n              decodeBase64Url(input.response.value.response.getPublicKey)\n            )\n          ),\n          getPublicKeyAlgorithm: decodePublicKeyAlgorithm(\n            input.response.value.response.getPublicKeyAlgorithm\n          ),\n          getTransports: input.response.value.response.getTransports,\n        },\n      },\n    },\n  };\n}\n\nexport function decodeAttestationObject(\n  data: string | Uint8Array\n): DecodedAttestationObject {\n  const buffer = data instanceof Uint8Array ? data : decodeBase64Url(data);\n  const cborMap = CBOR.decode(buffer.buffer)[0];\n  console.log({ cborMap, recursiveConvertArrayBufferToHexString });\n  return {\n    ...cborMap,\n    attStmt: recursiveConvertArrayBufferToHexString(cborMap.attStmt),\n    authData: decodeAuthenticatorData(cborMap.authData),\n  };\n}\n"],"x_google_ignoreList":[]}